<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Minecraft Command Generator Enhanced</title>
    <style>
        /* Base styles from previous version, with modifications */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0; /* Remove body padding for full-screen elements */
            margin: 0;
            background-color: #f0f2f5;
            color: #1c1e21;
            overscroll-behavior-y: contain;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* Prevent body scroll when panels manage their own */
        }
        #main-container {
            width: 100%;
            max-width: 500px; /* Maintain mobile-first focus for main content */
            margin: 0 auto; /* Center main container */
            display: flex;
            flex-direction: column;
            height: 100%; /* Full viewport height */
            box-sizing: border-box;
            padding: 10px; /* Padding for the content within main-container */
        }
        #command-display-area {
            background-color: #fff;
            border: 1px solid #ccd0d5;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 10px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            flex-shrink: 0; /* Prevent shrinking */
        }
        #command-built-area {
            flex-grow: 1;
            min-height: 48px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
            overflow-y: auto;
            max-height: 96px; /* Allow for 2 rows of buttons before scroll */
        }
        .command-part-btn {
            padding: 6px 10px;
            background-color: #e4e6eb;
            color: #050505;
            border: 1px solid #d1d3d6;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
            position: relative; /* For the 'change' popup */
        }
        .command-part-btn:hover { background-color: #d8dbdf; }

        .command-part-input { /* For actual text input fields if needed */
            padding: 6px 8px; border: 1px solid #1b74e4; border-radius: 4px;
            font-size: 0.9em; min-width: 80px;
        }

        .change-popup { /* JS will need to check bounds */
            position: absolute;
            /* bottom: -30px; Default, JS can flip to top */
            left: 50%;
            transform: translateX(-50%);
            background-color: #333; color: white; padding: 5px 10px;
            border-radius: 4px; z-index: 1000; cursor: pointer; font-size: 0.8em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        #copy-button {
            padding: 12px 15px; margin-left: 8px; background-color: #1b74e4;
            color: white; border: none; border-radius: 6px; cursor: pointer;
            font-size: 0.9em; font-weight: bold;
        }
        #copy-button:hover { background-color: #155bd8; } /* Corrected color */

        .button-panels-container { /* This is the main area for choice buttons */
            flex-grow: 1;
            overflow-y: auto;
            background-color: #ffffff;
            border: 1px solid #ccd0d5;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .button-panel { margin-bottom: 15px; }
        .button-panel h3 {
            margin-top: 0; margin-bottom: 10px; font-size: 1.1em; color: #606770;
            border-bottom: 1px solid #e4e6eb; padding-bottom: 5px;
        }

        /* Standard button grid for panels */
        .panel-button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
        }
        /* Standard button list for panels */
        .panel-button-list { display: flex; flex-direction: column; gap: 8px; }

        .panel-button { /* Default wide buttons */
            padding: 12px 10px; background-color: #f0f2f5; color: #050505;
            border: 1px solid #d1d3d6; border-radius: 6px; cursor: pointer;
            text-align: center; font-size: 0.95em; transition: background-color 0.2s;
        }
        .panel-button:hover { background-color: #e4e6eb; }
        .panel-button.primary { background-color: #1b74e4; color: white; font-weight: bold; }
        .panel-button.primary:hover { background-color: #155bd8; } /* Corrected color */

        /* Full-screen list container styles */
        .fullscreen-list-container {
            position: fixed; /* Take over screen */
            top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: #fff;
            z-index: 2000; /* Above everything */
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto; /* Scroll if content overflows */
            display: flex; /* For flex-wrap */
            flex-wrap: wrap; /* Allow buttons to wrap */
            gap: 6px; /* Spacing for small buttons */
            align-content: flex-start; /* Start items from top */
        }
        .fullscreen-list-container .list-item-button { /* Small, pill-shaped buttons for lists */
            padding: 6px 12px;
            background-color: #e4e6eb;
            color: #050505;
            border: 1px solid #d1d3d6;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
            /* No min-width, let them size to content */
        }
         .fullscreen-list-container .list-item-button:hover { background-color: #d8dbdf; }
         .fullscreen-list-header { /* Optional header for full-screen lists */
            width: 100%;
            padding: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            flex-basis: 100%; /* Take full width */
         }
         .fullscreen-list-back-button {
            position: fixed;
            top: 15px; right: 15px;
            z-index: 2001; /* Above the list content */
            padding: 8px 12px;
            background-color: #050505;
            color: white;
            border: none;
            border-radius: 50%; /* Circular */
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
         }


        /* Keypad Styles (as before) */
        #keypad-container {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: #d1d3d6; padding: 10px; border-top: 1px solid #b0b3b8;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1); z-index: 1000;
            display: none; /* Hidden initially */
            grid-template-columns: repeat(4, 1fr); gap: 5px;
        }
        #keypad-container button {
            padding: 15px 10px; font-size: 1.2em; background-color: #f0f2f5;
            border: 1px solid #b0b3b8; border-radius: 5px; cursor: pointer;
        }
        #keypad-container button:active { background-color: #b0b3b8; }
        #keypad-display {
            grid-column: span 4; background-color: #fff; border: 1px solid #b0b3b8;
            padding: 10px; text-align: right; font-size: 1.2em; margin-bottom: 5px; min-height: 24px;
        }

        /* Initial hide for panels not active */
        .button-panel:not(#panel-initial) { display: none; }
        .fullscreen-list-container { display: none; } /* Hidden initially */

    </style>
</head>
<body>
    <div id="main-container">
        <div id="command-display-area">
            <div id="command-built-area"></div>
            <button id="copy-button">Copy</button>
        </div>

        <div class="button-panels-container">
            <div id="panel-initial" class="button-panel">
                <div class="panel-button-list">
                    <button id="start-execute-button" class="panel-button primary" data-command-part="/execute">Start with /execute</button>
                </div>
            </div>

            <div id="panel-execute-subcommands" class="button-panel">
                <h3>Execute Subcommands</h3>
                <div class="panel-button-grid">
                    <button class="panel-button" data-subcommand="as">as</button>
                    <button class="panel-button" data-subcommand="at">at</button>
                    <button class="panel-button" data-subcommand="in">in</button>
                    <button class="panel-button" data-subcommand="positioned">positioned</button>
                    <button class="panel-button" data-subcommand="align">align</button>
                    <button class="panel-button" data-subcommand="anchored">anchored</button>
                    <button class="panel-button" data-subcommand="rotated">rotated</button>
                    <button class="panel-button" data-subcommand="facing">facing</button>
                    <button class="panel-button" data-subcommand="if">if</button>
                    <button class="panel-button" data-subcommand="unless">unless</button>
                    <button class="panel-button primary" data-subcommand="run">run</button>
                </div>
            </div>

            <div id="panel-targets" class="button-panel">
                <h3>Target Selectors</h3>
                <div class="panel-button-grid">
                    <button class="panel-button" data-selector="@p">@p</button>
                    <button class="panel-button" data-selector="@r">@r</button>
                    <button class="panel-button" data-selector="@a">@a</button>
                    <button class="panel-button" data-selector="@s">@s</button>
                    <button class="panel-button" data-selector="@e">@e</button>
                    <button class="panel-button" data-action="manual-selector-entry">[Type Selector/Name]</button>
                </div>
            </div>
            
            <div id="panel-selector-activated" class="button-panel">
                <h3>Selector Active: Add Argument or Continue</h3>
                <div id="current-active-selector-display" style="margin-bottom:10px; font-weight:bold;"></div>
                
                <section>
                    <h4>Selector Arguments</h4>
                    <div id="selector-args-options-container" class="panel-button-grid">
                        <button class="panel-button" data-selector-arg="type">type=</button>
                        <button class="panel-button" data-selector-arg="name">name=</button>
                        <button class="panel-button" data-selector-arg="tag">tag=</button>
                        <button class="panel-button" data-selector-arg="limit">limit=</button>
                        </div>
                </section>
                <hr style="margin: 15px 0;">
                <section>
                    <h4>Or Continue With Next Execute Subcommand</h4>
                    <div id="selector-next-execute-options-container" class="panel-button-grid">
                        </div>
                </section>
            </div>
            
            <div id="panel-dimensions" class="button-panel">
                 <h3>Dimension</h3>
                 <div class="panel-button-grid">
                    <button class="panel-button" data-dimension="overworld">overworld</button>
                    <button class="panel-button" data-dimension="the_nether">the_nether</button>
                    <button class="panel-button" data-dimension="the_end">the_end</button>
                </div>
            </div>


        </div> </div> <div id="fullscreen-entity-list" class="fullscreen-list-container">
        <button class="fullscreen-list-back-button" data-action="close-fullscreen-list" data-target-panel-id="panel-selector-activated">X</button>
        <h3 class="fullscreen-list-header">Select Entity Type</h3>
        </div>

    <div id="fullscreen-run-command-list" class="fullscreen-list-container">
        <button class="fullscreen-list-back-button" data-action="close-fullscreen-list" data-target-panel-id="panel-execute-subcommands">X</button>
        <h3 class="fullscreen-list-header">Choose Command to Run</h3>
        </div>

    <div id="keypad-container">
        <input type="text" id="keypad-display" readonly placeholder="0">
        <button data-key="7">7</button> <button data-key="8">8</button> <button data-key="9">9</button> <button data-key="~">~</button>
        <button data-key="4">4</button> <button data-key="5">5</button> <button data-key="6">6</button> <button data-key=".">.</button>
        <button data-key="1">1</button> <button data-key="2">2</button> <button data-key="3">3</button> <button data-key="-">-</button>
        <button data-key=" " style="font-size: 0.8em;">Spc</button> <button data-key="0">0</button> <button data-key="backspace" style="font-size: 0.8em;">DEL</button> <button data-key="enter" style="font-size: 0.8em;" class="primary">OK</button>
    </div>

    <script>
        // --- DATA STORE (Examples - these would be extensive) ---
        const MINECRAFT_ENTITIES = [
            "allay", "area_effect_cloud", "armor_stand", "arrow", "axolotl", "bat", "bee", "blaze", 
            "boat", "camel", "cat", "cave_spider", "chest_boat", "chicken", "cod", "cow", "creeper", 
            "dolphin", "donkey", "dragon_fireball", "drowned", "egg", "elder_guardian", "end_crystal", 
            "ender_dragon", "ender_pearl", "enderman", "endermite", "evoker", "experience_bottle", 
            "experience_orb", "eye_of_ender", "falling_block", "fireball", "firework_rocket", "fishing_bobber",
            "fox", "frog", "ghast", "giant", "glow_item_frame", "glow_squid", "goat", "guardian", "hoglin", 
            "horse", "husk", "illusioner", "iron_golem", "item", "item_frame", "leash_knot", "lightning_bolt", 
            "llama", "llama_spit", "magma_cube", "marker", "minecart", "chest_minecart", "command_block_minecart",
            "furnace_minecart", "hopper_minecart", "spawner_minecart", "tnt_minecart", "mooshroom", "mule", 
            "ocelot", "painting", "panda", "parrot", "phantom", "pig", "piglin", "piglin_brute", "pillager", 
            "player", "polar_bear", "potion", "pufferfish", "rabbit", "ravager", "salmon", "sheep", "shulker", 
            "shulker_bullet", "silverfish", "skeleton", "skeleton_horse", "slime", "small_fireball", "sniffer",
            "snow_golem", "snowball", "spawner_minecart", "spectral_arrow", "spider", "squid", "stray", "strider",
            "tadpole", "text_display", "tnt", "tnt_minecart", "trader_llama", "trident", "tropical_fish", "turtle",
            "vex", "villager", "vindicator", "wandering_trader", "warden", "witch", "wither", "wither_skeleton",
            "wither_skull", "wolf", "zoglin", "zombie", "zombie_horse", "zombie_villager", "zombified_piglin"
        ];

        const RUN_COMMANDS_LIST = [
            { id: "say", name: "say", nextPanelIdOrAction: "handleSayCommand" },
            { id: "tp", name: "tp (teleport)", nextPanelIdOrAction: "panel-run-tp-args-target" }, // Placeholder
            { id: "summon", name: "summon", nextPanelIdOrAction: "handleSummonCommand" },
            { id: "gamemode", name: "gamemode", nextPanelIdOrAction: "handleGamemodeCommand"}, // Placeholder
            { id: "give", name: "give", nextPanelIdOrAction: "handleGiveCommand"}, // Placeholder
             // ... many more commands
        ];

        // --- DOM ELEMENTS ---
        const commandBuiltArea = document.getElementById('command-built-area');
        const allPanels = document.querySelectorAll('.button-panel'); // MOVED HERE
        const copyButton = document.getElementById('copy-button'); // Added copyButton
        const mainPanelsContainer = document.querySelector('.button-panels-container');
        const fullscreenEntityList = document.getElementById('fullscreen-entity-list');
        const fullscreenRunCommandList = document.getElementById('fullscreen-run-command-list');
        const currentActiveSelectorDisplay = document.getElementById('current-active-selector-display');
        const selectorArgsOptionsContainer = document.getElementById('selector-args-options-container');
        const selectorNextExecuteOptionsContainer = document.getElementById('selector-next-execute-options-container');
        const keypadContainer = document.getElementById('keypad-container');
        const keypadDisplay = document.getElementById('keypad-display');


        // --- STATE ---
        let commandParts = [];
        let currentPanelId = 'panel-initial';
        let activeInputTarget = null; 
        let pendingSelector = null; 
        let isSelectorArgumentActive = false;

        // --- INITIALIZATION ---
        function initialize() {
            showPanel('panel-initial'); 
            hideFullscreenLists();    
            populateRunCommandListForFullscreen(); 
            populateEntityListForFullscreen();     
            const execSubcommandsPanel = document.getElementById('panel-execute-subcommands').querySelector('.panel-button-grid');
            if (execSubcommandsPanel) {
                selectorNextExecuteOptionsContainer.innerHTML = execSubcommandsPanel.innerHTML;
            }
            setupEventListeners(); 
        }
        
        function hideFullscreenLists() {
            fullscreenEntityList.style.display = 'none';
            fullscreenRunCommandList.style.display = 'none';
        }

        function showFullscreenList(listId) {
            // console.log("Showing fullscreen list:", listId);
            allPanels.forEach(panel => panel.style.display = 'none'); // Hide main panels too
            hideFullscreenLists(); 
            if (listId === 'fullscreen-entity-list') fullscreenEntityList.style.display = 'flex';
            if (listId === 'fullscreen-run-command-list') fullscreenRunCommandList.style.display = 'flex';
            mainPanelsContainer.style.display = 'none'; 
        }

        function hideCurrentFullscreenListAndShowPanel(panelId) {
            // console.log("Hiding fullscreen, showing panel:", panelId);
            hideFullscreenLists();
            mainPanelsContainer.style.display = 'block'; 
            if (panelId) { // only show panel if one is specified
                showPanel(panelId);
            } else { // If no panelId, make sure something reasonable is shown (e.g. initial if all else fails)
                showPanel(currentPanelId || 'panel-initial');
            }
        }

        function populateEntityListForFullscreen() {
            const container = fullscreenEntityList; 
            container.querySelectorAll('.list-item-button').forEach(btn => btn.remove());

            MINECRAFT_ENTITIES.sort().forEach(entity => {
                const button = document.createElement('button');
                button.className = 'list-item-button';
                button.textContent = entity;
                button.dataset.entityType = entity;
                // Add event listener directly here for simplicity now
                button.addEventListener('click', () => handleEntityTypeSelection(entity));
                container.appendChild(button);
            });
        }
        
        function populateRunCommandListForFullscreen() {
            const container = fullscreenRunCommandList;
            container.querySelectorAll('.list-item-button').forEach(btn => btn.remove());

            RUN_COMMANDS_LIST.forEach(cmd => {
                const button = document.createElement('button');
                button.className = 'list-item-button';
                button.textContent = cmd.name;
                button.dataset.runCommand = cmd.id;
                button.dataset.nextAction = cmd.nextPanelIdOrAction; 
                // Add event listener directly here
                button.addEventListener('click', () => handleRunCommandSelection(cmd));
                container.appendChild(button);
            });
        }

        function showPanel(panelId) {
            // console.log("Showing panel:", panelId);
            if (!allPanels) { // Should not happen if allPanels is defined globally
                console.error("allPanels is not defined!");
                return;
            }
            allPanels.forEach(panel => panel.style.display = 'none');
            const panelToShow = document.getElementById(panelId);
            if (panelToShow) {
                panelToShow.style.display = 'block';
                currentPanelId = panelId;
            } else {
                console.warn("Panel not found:", panelId, "defaulting to panel-initial");
                document.getElementById('panel-initial').style.display = 'block';
                currentPanelId = 'panel-initial';
            }
            if (keypadContainer) keypadContainer.style.display = 'none';
        }

        function addCommandSegment(text, type, options = {}) {
            const cleanText = text; // Brackets/commas are now mostly visual, not stored directly if implicit
            const segment = {
                id: `cmd-part-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                text: cleanText,
                type: type,
                hasBrackets: options.hasBrackets || false, 
                isPlaceholder: options.isPlaceholder || false,
                requiresInput: options.requiresInput || null,
                originalCommand: options.originalCommand || null, // To know what this segment was for
                nextPanelAfterInput: options.nextPanelAfterInput || null,
                valuePlaceholderId: options.valuePlaceholderId || null, // If this is a key, store ID of its value placeholder
                ...options
            };
            commandParts.push(segment);
            renderCommandBuiltArea();
            
            if (segment.requiresInput) {
                handleRequiredInput(segment);
            }
        }

        function renderCommandBuiltArea() {
            commandBuiltArea.innerHTML = '';
            let openBracketForSelector = null; // Track if a selector has opened brackets

            commandParts.forEach((part, index) => {
                let partTextForDisplay = part.text;
                let prefix = "";

                // Handle selector base: add "[" if it hasBrackets
                if (part.type === 'selector_base' && part.hasBrackets) {
                    partTextForDisplay += "[";
                    openBracketForSelector = part.id; // Mark this selector as having an open bracket
                }

                // Add comma before a new selector argument key, if needed
                if (part.type === 'selector_arg_key' && openBracketForSelector) {
                    let needsComma = false;
                    // Look backwards for previous arg_key or arg_value related to the current openBracketForSelector
                    for (let j = index - 1; j >= 0; j--) {
                        const prevPart = commandParts[j];
                        if (prevPart.type === 'selector_base' && prevPart.id === openBracketForSelector) break; // Reached the selector itself
                        if (prevPart.type === 'selector_arg_value' || prevPart.type === 'selector_arg_key') {
                            needsComma = true;
                            break;
                        }
                    }
                    if (needsComma) prefix = ", "; // Add space for readability
                }
                
                const partBtn = document.createElement('button');
                partBtn.className = 'command-part-btn';
                partBtn.textContent = prefix + partTextForDisplay;
                partBtn.dataset.partId = part.id;
                partBtn.dataset.partIndex = index;

                partBtn.addEventListener('click', (e) => {
                    e.stopPropagation(); 
                    showChangeOption(partBtn, part.id, index);
                });
                commandBuiltArea.appendChild(partBtn);
            });

            // If a selector had brackets and we're no longer adding args to it, close the bracket
            if (openBracketForSelector && !isSelectorArgumentActive && pendingSelector === null) {
                // Check if the last part was related to this selector's arguments
                // Or if the overall state indicates arguments are done for this selector
                 const lastPart = commandParts[commandParts.length-1];
                 let argumentRelated = false;
                 if (lastPart) {
                    if (lastPart.type.startsWith('selector_arg') || (lastPart.type === 'selector_base' && lastPart.id === openBracketForSelector)){
                        // Still in argument mode or just added the selector with brackets
                        argumentRelated = true; 
                    }
                 }
                 // If the last segment is NOT argument related for the open selector, and selector is not pending for more args
                 if (!argumentRelated && !isSelectorArgumentActive) {
                    const bracketBtn = document.createElement('button');
                    bracketBtn.className = 'command-part-btn';
                    bracketBtn.textContent = ']';
                    bracketBtn.disabled = true; 
                    commandBuiltArea.appendChild(bracketBtn);
                    openBracketForSelector = null; // Bracket is now closed
                 }
            } else if (openBracketForSelector && commandParts.some(p => p.type === 'selector_args_end_implicitly')) {
                // If an implicit end marker was added
                const bracketBtn = document.createElement('button');
                bracketBtn.className = 'command-part-btn';
                bracketBtn.textContent = ']';
                bracketBtn.disabled = true; 
                commandBuiltArea.appendChild(bracketBtn);
                openBracketForSelector = null; 
                commandParts = commandParts.filter(p => p.type !== 'selector_args_end_implicitly'); // Clean up marker
            }
        }
        
        let currentChangePopup = null;
        function showChangeOption(parentButton, partId, index) {
            if (currentChangePopup) {
                currentChangePopup.remove();
                currentChangePopup = null;
            }
            const popup = document.createElement('div'); 
            popup.className = 'change-popup';
            popup.textContent = 'Change';
            
            popup.addEventListener('click', (e) => {
                e.stopPropagation();
                handleChangeCommandPart(index); // Implement this logic
                if (popup.parentNode) popup.remove();
                currentChangePopup = null;
            });
            parentButton.appendChild(popup);
            currentChangePopup = popup;

            const parentRect = parentButton.getBoundingClientRect();
            const containerRect = commandBuiltArea.getBoundingClientRect(); // Use commandBuiltArea
            const popupRect = popup.getBoundingClientRect();

            // Check if popup would go below the visible part of commandBuiltArea
            if (parentRect.bottom - containerRect.top + popupRect.height > containerRect.height) {
                popup.style.bottom = 'auto';
                popup.style.top = `-${popupRect.height + 2}px`; 
            } else {
                popup.style.top = 'auto';
                popup.style.bottom = `-${popupRect.height + 2}px`; 
            }
            
            setTimeout(() => { 
                 document.body.addEventListener('click', () => {
                    if(currentChangePopup && currentChangePopup.parentNode) currentChangePopup.remove();
                    currentChangePopup = null;
                 }, { once: true });
            },0);
        }

        function handleChangeCommandPart(index) {
            console.log("Attempting to change part at index:", index, commandParts[index]);
            const partToChange = commandParts[index];
            let sourcePanelForChange = partToChange.sourcePanelId || 'panel-initial'; // Store panel before slice
            
            commandParts = commandParts.slice(0, index); 
            
            // Reset states related to what was potentially being built
            pendingSelector = null;
            isSelectorArgumentActive = false;
            activeInputTarget = null;

            renderCommandBuiltArea();

            // Determine which panel to return to. This needs to be more intelligent.
            // For now, use the sourcePanelId of the part being changed.
            // If changing '/execute', go to initial.
            // If changing 'as', go to execute_subcommands.
            // If changing a selector '@e', go to 'panel-targets' or equivalent for that context.
            // If changing 'type=', go to 'panel-selector-activated' with the selector active.

            // Simplistic return for now:
            if (partToChange.type === 'execute_start') {
                 showPanel('panel-initial');
            } else if (partToChange.type === 'execute_subcommand') {
                 showPanel('panel-execute-subcommands');
            } else if (partToChange.type === 'selector_base') {
                // If it was a selector, we need to know what prompted this selector.
                // e.g., if after 'as', go to 'panel-targets'.
                // This needs more context stored in commandParts or a better state machine.
                // For now, try its source panel or a default.
                showPanel(sourcePanelForChange);
            } else if (partToChange.type.startsWith('selector_arg')) {
                // Find the selector this argument belonged to
                let parentSelectorPart = null;
                for(let i = index -1; i >= 0; i--) {
                    if (commandParts[i] && commandParts[i].type === 'selector_base' && commandParts[i].hasBrackets) {
                        parentSelectorPart = commandParts[i];
                        break;
                    }
                }
                if (parentSelectorPart) {
                    pendingSelector = parentSelectorPart.text; // Restore pending selector
                    isSelectorArgumentActive = true; // Assume we want to continue adding args
                    currentActiveSelectorDisplay.textContent = `Editing: ${pendingSelector}`;
                    showPanel('panel-selector-activated');
                } else {
                     showPanel('panel-selector-activated'); // Fallback
                }
            }
            else {
                showPanel(sourcePanelForChange);
            }
        }


        function handleRequiredInput(segment) {
            activeInputTarget = segment; 
            switch (segment.requiresInput) {
                case 'keypad_coordinates':
                case 'keypad_number':
                    keypadDisplay.value = segment.isPlaceholder ? '' : segment.text;
                    keypadDisplay.placeholder = segment.placeholder || 'Enter value...';
                    keypadContainer.style.display = 'grid';
                    break;
                case 'text_input':
                    const inputElem = document.createElement('input');
                    inputElem.type = 'text';
                    inputElem.className = 'command-part-input';
                    inputElem.placeholder = segment.placeholder || 'Type here...';
                    inputElem.value = segment.isPlaceholder ? '' : segment.text;
                    
                    const tempInputContainer = document.createElement('span'); // Temporary container
                    tempInputContainer.appendChild(inputElem);
                    commandBuiltArea.appendChild(tempInputContainer); // Add to command bar
                    inputElem.focus();
                    inputElem.scrollIntoView({behavior: "smooth", block: "nearest"});


                    inputElem.addEventListener('keypress', function(e) {
                        if (e.key === 'Enter') {
                            e.preventDefault(); // Prevent form submission if any
                            finalizeTextInput(inputElem.value.trim(), segment);
                            if (tempInputContainer.parentNode) tempInputContainer.remove();
                        }
                    });
                    inputElem.addEventListener('blur', function() { // Finalize on blur too
                         setTimeout(() => { // Timeout to allow click on other buttons before removing
                            if (tempInputContainer.parentNode) { // Check if still there
                                finalizeTextInput(inputElem.value.trim(), segment);
                                tempInputContainer.remove();
                            }
                        }, 100); // Small delay
                    }, { once: false }); // Allow multiple blurs if focus is regained quickly
                    break;
                // case 'entity_list': // This is now handled by showFullscreenList
                //     showFullscreenList('fullscreen-entity-list');
                //     break;
                default:
                    const nextPanel = segment.nextPanelAfterInput || getNextPanelForCommand(segment.text.trim().toLowerCase());
                    if(nextPanel) showPanel(nextPanel);
                    break;
            }
        }
        
        function finalizeTextInput(value, targetSegment) {
            if (targetSegment) {
                const segmentIndex = commandParts.findIndex(p => p.id === targetSegment.id);
                if (segmentIndex !== -1) {
                    commandParts[segmentIndex].text = value || targetSegment.placeholder || "[value]"; // Use placeholder if empty
                    commandParts[segmentIndex].isPlaceholder = false;
                    commandParts[segmentIndex].requiresInput = null; 
                }
                renderCommandBuiltArea(); 
                
                if (targetSegment.nextPanelAfterInput) {
                    showPanel(targetSegment.nextPanelAfterInput);
                } else if (targetSegment.originalCommand && targetSegment.originalCommand.includes('selector_arg')) {
                    showPanel('panel-selector-activated');
                } else {
                    showPanel('panel-execute-subcommands'); // Fallback
                }
            }
            activeInputTarget = null;
        }

        function setupKeypadListeners() {
            if (!keypadContainer) return;
            keypadContainer.addEventListener('click', function(e) {
                if (e.target.tagName === 'BUTTON') {
                    const key = e.target.dataset.key;
                    if (activeInputTarget && activeInputTarget.requiresInput && activeInputTarget.requiresInput.startsWith('keypad')) {
                        handleKeypadInput(key);
                    }
                }
            });
        }

        function handleKeypadInput(key) {
            if (!activeInputTarget) return;
            const segmentIndex = commandParts.findIndex(p => p.id === activeInputTarget.id);
            if (segmentIndex === -1) return;

            switch (key) {
                case 'enter':
                    commandParts[segmentIndex].text = keypadDisplay.value.trim() || commandParts[segmentIndex].placeholder || "[value]";
                    commandParts[segmentIndex].isPlaceholder = false;
                    commandParts[segmentIndex].requiresInput = null; 
                    renderCommandBuiltArea();
                    keypadContainer.style.display = 'none';
                    
                    if(commandParts[segmentIndex].nextPanelAfterInput) {
                        showPanel(commandParts[segmentIndex].nextPanelAfterInput);
                    } else if (commandParts[segmentIndex].originalCommand && commandParts[segmentIndex].originalCommand.includes('selector_arg')) {
                         showPanel('panel-selector-activated');
                    } else {
                        showPanel('panel-execute-subcommands'); // Default after keypad
                    }
                    activeInputTarget = null;
                    break;
                case 'backspace':
                    keypadDisplay.value = keypadDisplay.value.slice(0, -1);
                    break;
                default: 
                    keypadDisplay.value += key;
                    break;
            }
        }
        

        // --- EVENT LISTENERS SETUP ---
        function setupEventListeners() {
            // Start Execute Button
            const startExecuteBtn = document.getElementById('start-execute-button');
            if (startExecuteBtn) {
                startExecuteBtn.addEventListener('click', () => {
                    commandParts = []; pendingSelector = null; isSelectorArgumentActive = false;
                    addCommandSegment('/execute', 'execute_start', {sourcePanelId: 'panel-initial'});
                    showPanel('panel-execute-subcommands');
                });
            } else {
                console.error("Start Execute Button not found!");
            }


            // --- SELECTOR ACTIVATED PANEL LOGIC ---
            document.querySelectorAll('#panel-targets .panel-button[data-selector]').forEach(button => {
                button.addEventListener('click', () => {
                    pendingSelector = button.dataset.selector;
                    isSelectorArgumentActive = false; 
                    currentActiveSelectorDisplay.textContent = `Configure: ${pendingSelector}`;
                    // Populate the next execute options in the selector-activated panel
                    const execSubcommandsContent = document.getElementById('panel-execute-subcommands').querySelector('.panel-button-grid').innerHTML;
                    selectorNextExecuteOptionsContainer.innerHTML = execSubcommandsContent;
                    // Re-attach listeners for these newly cloned buttons
                    attachListenersToSelectorNextExecuteOptions();
                    showPanel('panel-selector-activated');
                });
            });
            
            // Manual selector entry button
            const manualSelEntryBtn = document.querySelector('#panel-targets .panel-button[data-action="manual-selector-entry"]');
            if(manualSelEntryBtn) {
                manualSelEntryBtn.addEventListener('click', () => {
                    addCommandSegment('[selector/name]', 'selector_value', {
                        isPlaceholder: true,
                        requiresInput: 'text_input',
                        placeholder: 'Type selector/name...',
                        originalCommand: 'manual_selector',
                        nextPanelAfterInput: 'panel-execute-subcommands' // Or back to selector context
                    });
                });
            }


            selectorArgsOptionsContainer.addEventListener('click', (e) => {
                if (e.target.matches('.panel-button[data-selector-arg]')) {
                    if (!pendingSelector) return; 

                    if (!isSelectorArgumentActive) {
                         addCommandSegment(pendingSelector, 'selector_base', { hasBrackets: true, sourcePanelId: 'panel-selector-activated' });
                         isSelectorArgumentActive = true;
                    }
                    const argKey = e.target.dataset.selectorArg;
                    const valuePlaceholderId = `val-placeholder-${Date.now()}`;
                    addCommandSegment(argKey + "=", 'selector_arg_key', {originalCommand: argKey, valuePlaceholderId: valuePlaceholderId, sourcePanelId: 'panel-selector-activated'}); 

                    if (argKey === 'type') {
                        activeInputTarget = { // Create a temporary active target for entity selection
                            type: 'selector_arg_key', // Simulating that 'type=' key is waiting for value
                            originalCommand: argKey, // 'type'
                            valuePlaceholderId: valuePlaceholderId // Link to the placeholder we're about to create implicitly
                        };
                        // Implicitly, a placeholder for the value is expected next for 'type='
                        // We don't add it to commandParts yet, handleEntityTypeSelection will.
                        showFullscreenList('fullscreen-entity-list');
                    } else if (argKey === 'limit' || argKey === 'distance' /* add other numeric selector args */) {
                        addCommandSegment(`[${argKey} val]`, 'selector_arg_value', {id: valuePlaceholderId, isPlaceholder:true, requiresInput:'keypad_number', placeholder:'Enter number', originalCommand: argKey, nextPanelAfterInput:'panel-selector-activated', sourcePanelId: 'panel-selector-activated'});
                    } else { 
                        addCommandSegment(`[${argKey} val]`, 'selector_arg_value', {id: valuePlaceholderId, isPlaceholder:true, requiresInput:'text_input', placeholder:'Enter value...', originalCommand: argKey, nextPanelAfterInput:'panel-selector-activated', sourcePanelId: 'panel-selector-activated'});
                    }
                }
            });
            
            // Initial attachment for next execute options (will be re-attached when panel-targets populates it)
            attachListenersToSelectorNextExecuteOptions();


            function attachListenersToSelectorNextExecuteOptions() {
                selectorNextExecuteOptionsContainer.querySelectorAll('.panel-button[data-subcommand]').forEach(button => {
                    // Clone button to remove old listeners, then add new one
                    const newButton = button.cloneNode(true);
                    button.parentNode.replaceChild(newButton, button);

                    newButton.addEventListener('click', (e) => {
                        if (!pendingSelector) return;

                        if (isSelectorArgumentActive) { 
                            addCommandSegment('', 'selector_args_end_implicitly', {sourcePanelId: 'panel-selector-activated'}); 
                            isSelectorArgumentActive = false;
                        } else {
                            addCommandSegment(pendingSelector, 'selector_base', { hasBrackets: false, sourcePanelId: 'panel-selector-activated' });
                        }
                        
                        const subcommand = newButton.dataset.subcommand;
                        addCommandSegment(subcommand, 'execute_subcommand', {sourcePanelId: 'panel-selector-activated'}); 
                        pendingSelector = null; 

                        const nextPanel = getNextPanelForExecuteSubcommand(subcommand);
                        showPanel(nextPanel);
                    });
                });
            }
            
            document.querySelectorAll('.fullscreen-list-back-button').forEach(button => {
                button.addEventListener('click', () => {
                    const targetPanel = button.dataset.targetPanelId || 'panel-execute-subcommands'; 
                    hideCurrentFullscreenListAndShowPanel(targetPanel);
                    if (pendingSelector && (activeInputTarget || isSelectorArgumentActive) ) { // If we were in the middle of selector args
                         showPanel('panel-selector-activated'); 
                    }
                    activeInputTarget = null; // Clear target as we are backing out of a selection
                });
            });
            
            document.querySelectorAll('#panel-execute-subcommands .panel-button[data-subcommand]').forEach(button => {
                 button.addEventListener('click', () => {
                    const subcommand = button.dataset.subcommand;
                    if (isSelectorArgumentActive && pendingSelector) {
                        addCommandSegment('', 'selector_args_end_implicitly', {sourcePanelId: 'panel-execute-subcommands'});
                        isSelectorArgumentActive = false;
                        pendingSelector = null;
                    }
                    addCommandSegment(subcommand, 'execute_subcommand', {sourcePanelId: 'panel-execute-subcommands'});
                    const nextPanel = getNextPanelForExecuteSubcommand(subcommand);
                    if (nextPanel) { // Check if nextPanel is valid
                        showPanel(nextPanel);
                    }
                 });
            });

            // Dimensions panel buttons
            document.querySelectorAll('#panel-dimensions .panel-button[data-dimension]').forEach(button => {
                button.addEventListener('click', () => {
                    addCommandSegment(button.dataset.dimension, 'dimension_value', {sourcePanelId: 'panel-dimensions'});
                    showPanel('panel-execute-subcommands'); // Go back to main subcommands
                });
            });
            
            // Copy Button
            if(copyButton) {
                copyButton.addEventListener('click', () => {
                    let commandText = "";
                    let openBracketForSelectorCopy = null;

                    commandParts.forEach((part, index) => {
                        let partStr = part.text;
                        let prefixCopy = " "; // Default space

                        if (index === 0 && partStr.startsWith('/')) prefixCopy = ""; // No space before /

                        if (part.type === 'selector_base' && part.hasBrackets) {
                            partStr += "[";
                            openBracketForSelectorCopy = part.id;
                        } else if (part.type === 'selector_arg_key' && openBracketForSelectorCopy) {
                            let needsCommaCopy = false;
                            for (let j = index - 1; j >= 0; j--) {
                                const prevPart = commandParts[j];
                                if (prevPart.type === 'selector_base' && prevPart.id === openBracketForSelectorCopy) break;
                                if (prevPart.type === 'selector_arg_value' || prevPart.type === 'selector_arg_key') {
                                    needsCommaCopy = true; break;
                                }
                            }
                            if (needsCommaCopy) prefixCopy = ","; // No space before comma, space after is default
                        } else if (part.type === 'selector_args_end_implicitly') {
                            partStr = "]"; // Render the closing bracket
                            prefixCopy = ""; // No space before closing bracket
                            openBracketForSelectorCopy = null;
                        }
                        
                        // Avoid double spaces if prefix is already a space and part is not a comma etc.
                        if (prefixCopy === " " && commandText.endsWith(" ")) {
                            prefixCopy = "";
                        }
                         if (prefixCopy === "," && commandText.endsWith(" ")) { // if commandText ends with "type=[" remove space before comma
                            if(commandText.endsWith('[') || commandText.endsWith('=')) { // if it ends with [ or = (like type=)
                                commandText = commandText.slice(0, -1); // Remove trailing space if any
                            }
                        }


                        commandText += prefixCopy + partStr;
                    });
                    // Final check if an implicit bracket needs closing if it was the last thing
                    if (openBracketForSelectorCopy && commandParts.some(p => p.id === openBracketForSelectorCopy && p.hasBrackets) && !commandText.endsWith("]")) {
                         if (isSelectorArgumentActive) commandText += "]"; // Close if we were actively adding
                    }


                    commandText = commandText.replace(/\s+/g, ' ').trim(); // Consolidate multiple spaces
                    // Refine spacing around brackets and commas for final output
                    commandText = commandText.replace(/\s*\[\s*/g, '['); // Remove space around [
                    commandText = commandText.replace(/\s*\]\s*/g, ']'); // Remove space around ]
                    commandText = commandText.replace(/\s*,\s*/g, ','); // Remove space around ,
                    commandText = commandText.replace(/,\s*=/g, '=');    // Remove space after comma if it's before = (e.g. @e[type=a,name=b])
                    commandText = commandText.replace(/=\s*,/g, '=');   // Should not happen often but good to check
                    commandText = commandText.replace(/\s*=\s*/g, '=');   // Remove space around =

                    navigator.clipboard.writeText(commandText)
                        .then(() => alert('Command copied: ' + commandText))
                        .catch(err => console.error('Failed to copy: ', err));
                });
            }
            setupKeypadListeners();

        } 
        
        function getNextPanelForExecuteSubcommand(subcommand) {
            // console.log("Getting next panel for execute subcommand:", subcommand);
            switch (subcommand) {
                case 'as': case 'at': return 'panel-targets';
                case 'in': return 'panel-dimensions';
                case 'run': showFullscreenList('fullscreen-run-command-list'); return currentPanelId; // Stays on current, fullscreen overlays it
                case 'positioned': case 'rotated': case 'facing':
                    addCommandSegment(`[${subcommand} val]`, `${subcommand}_value`, {
                        isPlaceholder: true, 
                        requiresInput: 'keypad_coordinates', 
                        placeholder: subcommand === 'rotated' ? 'yaw pitch' : 'x y z',
                        originalCommand: subcommand,
                        nextPanelAfterInput: 'panel-execute-subcommands',
                        sourcePanelId: currentPanelId
                    });
                    return currentPanelId; // Keypad will overlay
                case 'align':
                     addCommandSegment(`[axes]`, `align_value`, {
                        isPlaceholder: true, 
                        requiresInput: 'text_input', 
                        placeholder: 'e.g. xyz',
                        originalCommand: subcommand,
                        nextPanelAfterInput: 'panel-execute-subcommands',
                        sourcePanelId: currentPanelId
                    });
                    return currentPanelId; // Text input will be in command bar
                // TODO: Add cases for 'anchored', 'if', 'unless' to show their respective panels
                default: return 'panel-execute-subcommands'; 
            }
        }
        
        function handleEntityTypeSelection(entityType) {
            let valueSegmentToUpdate = null;
            // Scenario 1: activeInputTarget is set for a selector argument that expects an entity
            if (activeInputTarget && activeInputTarget.type === 'selector_arg_key' && activeInputTarget.originalCommand === 'type') {
                // We need to find or create the value segment for this key
                // The key (e.g. type=) was already added. We now add its value.
                addCommandSegment(entityType, 'selector_arg_value', {originalCommand: 'type_value', sourcePanelId: 'fullscreen-entity-list'});
                activeInputTarget = null; // consumed
            } 
            // Scenario 2: Summon command context
            else if (commandParts.length > 0 && commandParts[commandParts.length-1].text === 'summon') {
                addCommandSegment(entityType, 'entity_type_for_summon', {sourcePanelId: 'fullscreen-entity-list'});
                // TODO: Transition to get summon's next arguments (pos, nbt)
                // For now, just show next options for summon (e.g., position via keypad)
                 addCommandSegment(`[pos]`, `summon_pos_value`, {
                    isPlaceholder: true, 
                    requiresInput: 'keypad_coordinates', 
                    placeholder: 'x y z or ~ ~ ~',
                    originalCommand: 'summon_pos',
                    nextPanelAfterInput: 'panel-execute-subcommands', // Placeholder for further summon args
                    sourcePanelId: currentPanelId
                });
            } else {
                console.warn("handleEntityTypeSelection called out of context.");
                // Fallback or error display
            }
            renderCommandBuiltArea();
            hideCurrentFullscreenListAndShowPanel(pendingSelector ? 'panel-selector-activated' : 'panel-execute-subcommands');
        }

        function handleRunCommandSelection(commandInfo) {
            addCommandSegment(commandInfo.id, 'run_command_name', {sourcePanelId: 'fullscreen-run-command-list'});
            pendingSelector = null; isSelectorArgumentActive = false; 

            if (commandInfo.id === 'summon') {
                activeInputTarget = null; 
                hideCurrentFullscreenListAndShowPanel(null); 
                showFullscreenList('fullscreen-entity-list'); 
            } else if (commandInfo.id === 'say') {
                 addCommandSegment('[message]', 'run_command_arg', {isPlaceholder:true, requiresInput:'text_input', placeholder:'Type message...', nextPanelAfterInput:'panel-execute-subcommands', sourcePanelId: 'fullscreen-run-command-list'});
                 hideCurrentFullscreenListAndShowPanel('panel-execute-subcommands'); 
            }
            else if (typeof commandInfo.nextPanelIdOrAction === 'string' && commandInfo.nextPanelIdOrAction.startsWith('panel-')) {
                hideCurrentFullscreenListAndShowPanel(commandInfo.nextPanelIdOrAction);
            } else {
                hideCurrentFullscreenListAndShowPanel('panel-execute-subcommands'); 
            }
        }
        
        // Assign to window if needed by inline HTML listeners (though direct JS listeners are better)
        // window.handleEntityTypeSelection = handleEntityTypeSelection;
        // window.handleRunCommandSelection = handleRunCommandSelection;

        // --- START THE APP ---
        initialize();
    </script>
</body>
</html>
