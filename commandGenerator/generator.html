<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Minecraft Command Generator Pro (Revised)</title>
    <style>
        /* Base styles from previous version, with modifications */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 0; 
            margin: 0;
            background-color: #f0f2f5;
            color: #1c1e21;
            overscroll-behavior-y: contain;
            height: 100vh;
            width: 100vw;
            overflow: hidden; 
        }
        #main-container {
            width: 100%;
            max-width: 500px; 
            margin: 0 auto; 
            display: flex;
            flex-direction: column;
            height: 100%; 
            box-sizing: border-box;
            padding: 10px; 
        }
        #command-display-area {
            background-color: #fff;
            border: 1px solid #ccd0d5;
            border-radius: 8px;
            padding: 8px;
            margin-bottom: 10px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            flex-shrink: 0; 
        }
        #command-built-area {
            flex-grow: 1;
            min-height: 48px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 4px;
            overflow-y: auto;
            max-height: 100px; /* Increased slightly */
            padding-bottom: 5px; /* Space for potential 'change' popup overflow */
        }
        .command-part-btn, .command-part-char-display, .command-part-input-wrapper input {
            padding: 6px 10px;
            background-color: #e4e6eb;
            color: #050505;
            border: 1px solid #d1d3d6;
            border-radius: 15px;
            font-size: 0.9em;
            position: relative; 
            box-sizing: border-box;
            line-height: 1.2; /* Ensure text fits well */
            white-space: nowrap;
        }
        .command-part-btn { /* Clickable keyword/selector buttons */
            cursor: pointer;
        }
        .command-part-btn:hover { background-color: #d8dbdf; }

        .command-part-char-display { /* For [, ], , */
            background-color: #f0f2f5; /* Slightly different bg */
            cursor: default;
            padding: 6px 8px; /* একটু কম প্যাডিং */
        }
        
        .command-part-input-wrapper { /* Wrapper for input to maintain bubble shape */
            display: inline-block; /* To contain the input */
            padding: 0; margin:0; border:none; background:none;
        }
        .command-part-input-wrapper input {
            background-color: #fff; /* White background for input */
            border: 1px solid #1b74e4; /* Blue border when active */
            min-width: 60px; /* Minimum width for typing */
            max-width: 150px; /* Prevent overly long inputs */
            outline: none;
        }


        .change-popup { 
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            background-color: #333; color: white; padding: 5px 10px;
            border-radius: 4px; z-index: 1000; cursor: pointer; font-size: 0.8em;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            white-space: nowrap;
        }

        #copy-button {
            padding: 12px 15px; margin-left: 8px; background-color: #1b74e4;
            color: white; border: none; border-radius: 6px; cursor: pointer;
            font-size: 0.9em; font-weight: bold;
        }
        #copy-button:hover { background-color: #155bd8; } 

        .button-panels-container { 
            flex-grow: 1;
            overflow-y: auto;
            background-color: #ffffff;
            border: 1px solid #ccd0d5;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        .button-panel { margin-bottom: 15px; }
        .button-panel h3 {
            margin-top: 0; margin-bottom: 10px; font-size: 1.1em; color: #606770;
            border-bottom: 1px solid #e4e6eb; padding-bottom: 5px;
        }

        .panel-button-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 8px;
        }
        .panel-button-list { display: flex; flex-direction: column; gap: 8px; }

        .panel-button { 
            padding: 12px 10px; background-color: #f0f2f5; color: #050505;
            border: 1px solid #d1d3d6; border-radius: 6px; cursor: pointer;
            text-align: center; font-size: 0.95em; transition: background-color 0.2s;
        }
        .panel-button:hover { background-color: #e4e6eb; }
        .panel-button.primary { background-color: #1b74e4; color: white; font-weight: bold; }
        .panel-button.primary:hover { background-color: #155bd8; } 

        .fullscreen-list-container {
            position: fixed; 
            top: 0; left: 0; width: 100vw; height: 100vh;
            background-color: #fff;
            z-index: 2000; 
            padding: 10px;
            box-sizing: border-box;
            overflow-y: auto; 
            display: flex; 
            flex-wrap: wrap; 
            gap: 6px; 
            align-content: flex-start; 
        }
        .fullscreen-list-container .list-item-button { 
            padding: 6px 12px;
            background-color: #e4e6eb;
            color: #050505;
            border: 1px solid #d1d3d6;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.9em;
        }
         .fullscreen-list-container .list-item-button:hover { background-color: #d8dbdf; }
         .fullscreen-list-header { 
            width: 100%;
            padding: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
            flex-basis: 100%; 
         }
         .fullscreen-list-back-button {
            position: fixed;
            top: 15px; right: 15px;
            z-index: 2001; 
            padding: 8px 12px;
            background-color: #050505;
            color: white;
            border: none;
            border-radius: 50%; 
            font-size: 1em;
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
         }

        #keypad-container {
            position: fixed; bottom: 0; left: 0; right: 0;
            background-color: #d1d3d6; padding: 10px; border-top: 1px solid #b0b3b8;
            box-shadow: 0 -2px 5px rgba(0,0,0,0.1); z-index: 1000;
            display: none; 
            grid-template-columns: repeat(4, 1fr); gap: 5px;
        }
        #keypad-container button {
            padding: 15px 10px; font-size: 1.2em; background-color: #f0f2f5;
            border: 1px solid #b0b3b8; border-radius: 5px; cursor: pointer;
        }
        #keypad-container button:active { background-color: #b0b3b8; }
        #keypad-display {
            grid-column: span 4; background-color: #fff; border: 1px solid #b0b3b8;
            padding: 10px; text-align: right; font-size: 1.2em; margin-bottom: 5px; min-height: 24px;
        }

        .button-panel:not(#panel-initial) { display: none; }
        .fullscreen-list-container { display: none; } 

    </style>
</head>
<body>
    <div id="main-container">
        <div id="command-display-area">
            <div id="command-built-area"></div>
            <button id="copy-button">Copy</button>
        </div>

        <div class="button-panels-container">
            <div id="panel-initial" class="button-panel">
                <div class="panel-button-list">
                    <button id="start-execute-button" class="panel-button primary">Start with /execute</button>
                </div>
            </div>

            <div id="panel-execute-subcommands" class="button-panel">
                <h3>Execute Subcommands</h3>
                <div class="panel-button-grid">
                    <button class="panel-button" data-subcommand="as">as</button>
                    <button class="panel-button" data-subcommand="at">at</button>
                    <button class="panel-button" data-subcommand="in">in</button>
                    <button class="panel-button" data-subcommand="positioned">positioned</button>
                    <button class="panel-button" data-subcommand="align">align</button>
                    <button class="panel-button" data-subcommand="anchored">anchored</button>
                    <button class="panel-button" data-subcommand="rotated">rotated</button>
                    <button class="panel-button" data-subcommand="facing">facing</button>
                    <button class="panel-button" data-subcommand="if">if</button>
                    <button class="panel-button" data-subcommand="unless">unless</button>
                    <button class="panel-button primary" data-subcommand="run">run</button>
                </div>
            </div>

            <div id="panel-targets" class="button-panel">
                <h3>Target Selectors</h3>
                <div class="panel-button-grid">
                    <button class="panel-button" data-selector="@p">@p</button>
                    <button class="panel-button" data-selector="@r">@r</button>
                    <button class="panel-button" data-selector="@a">@a</button>
                    <button class="panel-button" data-selector="@s">@s</button>
                    <button class="panel-button" data-selector="@e">@e</button>
                    <button class="panel-button" data-action="manual-selector-entry">[Type Selector/Name]</button>
                </div>
            </div>
            
            <div id="panel-selector-activated" class="button-panel">
                <h3>Selector Active: <span id="current-active-selector-display" style="font-weight:bold;"></span></h3>
                <section>
                    <h4>Add Argument</h4>
                    <div id="selector-args-options-container" class="panel-button-grid">
                        <button class="panel-button" data-selector-arg-key="type">type=</button>
                        <button class="panel-button" data-selector-arg-key="name">name=</button>
                        <button class="panel-button" data-selector-arg-key="tag">tag=</button>
                        <button class="panel-button" data-selector-arg-key="limit">limit=</button>
                        </div>
                </section>
                <hr style="margin: 15px 0;">
                <section>
                    <h4>Or Continue With Next Subcommand</h4>
                    <div id="selector-next-execute-options-container" class="panel-button-grid">
                        </div>
                </section>
            </div>
            
            <div id="panel-dimensions" class="button-panel">
                 <h3>Dimension</h3>
                 <div class="panel-button-grid">
                    <button class="panel-button" data-dimension="overworld">overworld</button>
                    <button class="panel-button" data-dimension="the_nether">the_nether</button>
                    <button class="panel-button" data-dimension="the_end">the_end</button>
                </div>
            </div>

        </div> 
    </div> 
    
    <div id="fullscreen-entity-list" class="fullscreen-list-container">
        <button class="fullscreen-list-back-button" data-action="close-fullscreen-list">X</button>
        <h3 class="fullscreen-list-header">Select Entity Type</h3>
    </div>

    <div id="fullscreen-run-command-list" class="fullscreen-list-container">
        <button class="fullscreen-list-back-button" data-action="close-fullscreen-list">X</button>
        <h3 class="fullscreen-list-header">Choose Command to Run</h3>
    </div>

    <div id="keypad-container">
        <input type="text" id="keypad-display" readonly placeholder="0">
        <button data-key="7">7</button> <button data-key="8">8</button> <button data-key="9">9</button> <button data-key="~">~</button>
        <button data-key="4">4</button> <button data-key="5">5</button> <button data-key="6">6</button> <button data-key=".">.</button>
        <button data-key="1">1</button> <button data-key="2">2</button> <button data-key="3">3</button> <button data-key="-">-</button>
        <button data-key=" " style="font-size: 0.8em;">Spc</button> <button data-key="0">0</button> <button data-key="backspace" style="font-size: 0.8em;">DEL</button> <button data-key="enter" style="font-size: 0.8em;" class="primary">OK</button>
    </div>

    <script>
        // --- DATA STORE ---
        const MINECRAFT_ENTITIES = ["allay", "armor_stand", "arrow", "axolotl", "bat", "bee", "blaze", "boat", "cat", "cave_spider", "chest_boat", "chicken", "cod", "cow", "creeper", "dolphin", "donkey", "drowned", "egg", "elder_guardian", "end_crystal", "ender_dragon", "ender_pearl", "enderman", "endermite", "evoker", "experience_bottle", "experience_orb", "eye_of_ender", "falling_block", "fireball", "firework_rocket", "fishing_bobber", "fox", "frog", "ghast", "glow_item_frame", "glow_squid", "goat", "guardian", "hoglin", "horse", "husk", "iron_golem", "item", "item_frame", "leash_knot", "lightning_bolt", "llama", "magma_cube", "minecart", "mooshroom", "mule", "ocelot", "painting", "panda", "parrot", "phantom", "pig", "piglin", "pillager", "player", "polar_bear", "pufferfish", "rabbit", "ravager", "salmon", "sheep", "shulker", "silverfish", "skeleton", "skeleton_horse", "slime", "snow_golem", "snowball", "spider", "squid", "stray", "strider", "tadpole", "tnt", "trader_llama", "tropical_fish", "turtle", "vex", "villager", "vindicator", "wandering_trader", "warden", "witch", "wither", "wither_skeleton", "wolf", "zoglin", "zombie", "zombie_horse", "zombie_villager", "zombified_piglin"];
        const RUN_COMMANDS_LIST = [
            { id: "say", name: "say", handler: "handleSayCommand" },
            { id: "tp", name: "tp", handler: "handleTpCommand" },
            { id: "summon", name: "summon", handler: "handleSummonCommand" },
            { id: "give", name: "give", handler: "handleGiveCommand" },
            { id: "effect", name: "effect", handler: "handleEffectCommand" },
            { id: "gamemode", name: "gamemode", handler: "handleGamemodeCommand" },
            { id: "kill", name: "kill", handler: "handleKillCommand" },
            { id: "setblock", name: "setblock", handler: "handleSetblockCommand" },
            { id: "fill", name: "fill", handler: "handleFillCommand" },
            { id: "scoreboard", name: "scoreboard", handler: "handleScoreboardCommand" },
            { id: "tag", name: "tag", handler: "handleTagCommand" },
        ];

        // --- DOM ELEMENTS ---
        const commandBuiltArea = document.getElementById('command-built-area');
        const allPanels = document.querySelectorAll('.button-panel');
        const copyButton = document.getElementById('copy-button');
        const mainPanelsContainer = document.querySelector('.button-panels-container');
        const fullscreenEntityList = document.getElementById('fullscreen-entity-list');
        const fullscreenRunCommandList = document.getElementById('fullscreen-run-command-list');
        const currentActiveSelectorDisplay = document.getElementById('current-active-selector-display');
        const selectorArgsOptionsContainer = document.getElementById('selector-args-options-container');
        const selectorNextExecuteOptionsContainer = document.getElementById('selector-next-execute-options-container');
        const keypadContainer = document.getElementById('keypad-container');
        const keypadDisplay = document.getElementById('keypad-display');

        // --- STATE ---
        let commandParts = [];
        let currentPanelId = 'panel-initial';
        let activeInputTargetElement = null; // The actual input DOM element that has focus for keypad
        let pendingSelector = null; 
        let selectorArgState = { // To manage current selector arguments
            isActive: false,
            baseSelectorPartId: null, // ID of the @e part
            hasOpenBracket: false
        };


        // --- INITIALIZATION ---
        function initialize() {
            showPanel('panel-initial'); 
            hideFullscreenLists();    
            populateRunCommandListForFullscreen(); 
            populateEntityListForFullscreen();     
            const execSubcommandsPanelGrid = document.getElementById('panel-execute-subcommands').querySelector('.panel-button-grid');
            if (execSubcommandsPanelGrid) {
                selectorNextExecuteOptionsContainer.innerHTML = execSubcommandsPanelGrid.innerHTML;
            }
            setupEventListeners(); 
        }
        
        // --- Fullscreen List Management ---
        function hideFullscreenLists() { /* ... same ... */ }
        function showFullscreenList(listId, context = {}) { /* ... same ...; store context if needed */ }
        function hideCurrentFullscreenListAndShowPanel(panelId) { /* ... same ... */ }
        function populateEntityListForFullscreen() { /* ... same, ensure event listeners call correctly ... */ }
        function populateRunCommandListForFullscreen() { /* ... same ... */ }

        // --- Panel Management ---
        function showPanel(panelId) { /* ... same ... */ }

        // --- COMMAND BUILDING ---
        function addCommandSegment(text, type, options = {}) {
            const segment = {
                id: `cmd-part-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                text: text, // For inputs, this is their current value
                type: type, // 'keyword', 'selector_base', 'bracket_open', 'selector_arg_key', 'selector_arg_value_input', 'comma', 'bracket_close', 'entity_type_for_summon', 'run_command_name', 'coordinates_input', 'text_input'
                isEditableInput: options.isEditableInput || false, // True if this part is a persistent input field
                placeholder: options.placeholder || "",
                sourcePanelId: currentPanelId, // For "change" logic
                ...options
            };
            commandParts.push(segment);
            renderCommandBuiltArea();
            
            if (segment.isEditableInput && segment.requiresInput === 'keypad') {
                const inputElement = commandBuiltArea.querySelector(`input[data-part-id="${segment.id}"]`);
                if (inputElement) prepareKeypadForInput(inputElement, segment);
            } else if (segment.isEditableInput) {
                 const inputElement = commandBuiltArea.querySelector(`input[data-part-id="${segment.id}"]`);
                 if (inputElement) {
                    inputElement.focus();
                    inputElement.scrollIntoView({behavior: "smooth", block: "nearest"});
                 }
            }
        }

        function renderCommandBuiltArea() {
            commandBuiltArea.innerHTML = '';
            commandParts.forEach((part, index) => {
                let element;
                if (part.isEditableInput) {
                    const wrapper = document.createElement('div'); // Use a wrapper for easier styling if needed
                    wrapper.className = 'command-part-input-wrapper';
                    element = document.createElement('input');
                    element.type = 'text';
                    element.value = part.text;
                    element.placeholder = part.placeholder || 'value';
                    element.dataset.partId = part.id;
                    element.dataset.partIndex = index;
                    element.addEventListener('input', (e) => { // Update commandParts on every input
                        part.text = e.target.value;
                    });
                    if (part.requiresInput === 'keypad') {
                        element.readOnly = true; // Prevent keyboard, allow focus for keypad
                        element.addEventListener('focus', () => prepareKeypadForInput(element, part));
                         element.addEventListener('click', () => prepareKeypadForInput(element, part)); // Also on click
                    }
                    wrapper.appendChild(element);
                    commandBuiltArea.appendChild(wrapper);
                } else if (['bracket_open', 'bracket_close', 'comma'].includes(part.type)) {
                    element = document.createElement('span');
                    element.className = 'command-part-char-display';
                    element.textContent = part.text;
                    element.dataset.partId = part.id;
                    element.dataset.partIndex = index;
                    // These are not "Changeable" in the same way
                    commandBuiltArea.appendChild(element);
                } else { // Clickable keyword/selector buttons
                    element = document.createElement('button');
                    element.className = 'command-part-btn';
                    element.textContent = part.text;
                    element.dataset.partId = part.id;
                    element.dataset.partIndex = index;
                    element.addEventListener('click', (e) => {
                        e.stopPropagation(); 
                        showChangeOption(element, part.id, index);
                    });
                    commandBuiltArea.appendChild(element);
                }
            });
        }
        
        // --- Change Popup Logic ---
        let currentChangePopup = null;
        function showChangeOption(parentButtonOrInput, partId, index) {
            if (['bracket_open', 'bracket_close', 'comma'].includes(commandParts[index].type)) return; // Don't show for these

            if (currentChangePopup) {
                currentChangePopup.remove();
                currentChangePopup = null;
            }
            const popup = document.createElement('div'); 
            popup.className = 'change-popup';
            popup.textContent = 'Change';
            
            popup.addEventListener('click', (e) => {
                e.stopPropagation();
                handleChangeCommandPart(index); 
                if (popup.parentNode) popup.remove();
                currentChangePopup = null;
            });

            // If parent is input, append to its wrapper or commandBuiltArea directly and position
            let actualParentForPopup = parentButtonOrInput.classList.contains('command-part-input-wrapper') ? parentButtonOrInput : parentButtonOrInput;
            if (parentButtonOrInput.tagName === 'INPUT') { // If it's the input itself
                 actualParentForPopup = parentButtonOrInput.closest('.command-part-input-wrapper') || parentButtonOrInput;
            }


            actualParentForPopup.style.position = 'relative'; // Ensure parent is positioned for absolute child
            actualParentForPopup.appendChild(popup);
            currentChangePopup = popup;

            const parentRect = actualParentForPopup.getBoundingClientRect();
            const containerRect = commandBuiltArea.getBoundingClientRect(); 
            const popupRect = popup.getBoundingClientRect();

            if (parentRect.bottom - containerRect.top + popupRect.height + 5 > containerRect.height) { // 5 for some margin
                popup.style.bottom = 'auto';
                popup.style.top = `-${popupRect.height + 2}px`; 
            } else {
                popup.style.top = 'auto';
                popup.style.bottom = `-${popupRect.height + 2}px`; 
            }
            
            setTimeout(() => { 
                 document.body.addEventListener('click', () => {
                    if(currentChangePopup && currentChangePopup.parentNode) currentChangePopup.remove();
                    currentChangePopup = null;
                 }, { once: true });
            }, 0);
        }

        function handleChangeCommandPart(index) { /* ... needs careful implementation ... */ }

        // --- Keypad ---
        function prepareKeypadForInput(inputElement, partData) {
            if (!inputElement) return;
            keypadDisplay.value = inputElement.value || "";
            keypadDisplay.placeholder = partData.placeholder || "Enter value";
            activeInputTargetElement = inputElement; // Store the DOM input element
             activeInputTarget = partData; // Keep storing the part data object too
            keypadContainer.style.display = 'grid';
            inputElement.focus(); // Keep focus on the field
        }
        function setupKeypadListeners() { /* ... same, but updates activeInputTargetElement.value and partData.text ... */ }
        function handleKeypadInput(key) {
             if (!activeInputTargetElement || !activeInputTarget) return;

            switch (key) {
                case 'enter':
                    // Value already updated in activeInputTargetElement.value via keypadDisplay
                    // Update the corresponding commandParts item
                    const partToUpdate = commandParts.find(p => p.id === activeInputTarget.id);
                    if (partToUpdate) partToUpdate.text = activeInputTargetElement.value;
                    
                    renderCommandBuiltArea(); // Re-render to show static value if needed, though it's an input
                    keypadContainer.style.display = 'none';
                    
                    const nextPanel = activeInputTarget.nextPanelAfterInput;
                    activeInputTargetElement = null; 
                    activeInputTarget = null;
                    if(nextPanel) showPanel(nextPanel);
                    else if (selectorArgState.isActive) showPanel('panel-selector-activated');
                    else showPanel('panel-execute-subcommands');
                    break;
                case 'backspace':
                    keypadDisplay.value = keypadDisplay.value.slice(0, -1);
                    activeInputTargetElement.value = keypadDisplay.value; // Sync back
                    if(activeInputTarget) activeInputTarget.text = keypadDisplay.value;
                    break;
                default: 
                    keypadDisplay.value += key;
                    activeInputTargetElement.value = keypadDisplay.value; // Sync back
                    if(activeInputTarget) activeInputTarget.text = keypadDisplay.value;
                    break;
            }
        }


        // --- EVENT LISTENERS SETUP ---
        function setupEventListeners() {
            document.getElementById('start-execute-button').addEventListener('click', () => {
                commandParts = []; 
                pendingSelector = null; 
                selectorArgState = { isActive: false, baseSelectorPartId: null, hasOpenBracket: false };
                addCommandSegment('/execute', 'keyword', {sourcePanelId: 'panel-initial'});
                showPanel('panel-execute-subcommands');
            });

            // --- Panel Targets (Selectors like @e) ---
            document.querySelectorAll('#panel-targets .panel-button[data-selector]').forEach(button => {
                button.addEventListener('click', () => {
                    pendingSelector = button.dataset.selector;
                    selectorArgState = { isActive: false, baseSelectorPartId: null, hasOpenBracket: false }; // Reset for new pending selector
                    currentActiveSelectorDisplay.textContent = pendingSelector;
                    
                    const execSubcommandsPanelGrid = document.getElementById('panel-execute-subcommands').querySelector('.panel-button-grid');
                    if (execSubcommandsPanelGrid) {
                        selectorNextExecuteOptionsContainer.innerHTML = execSubcommandsPanelGrid.innerHTML;
                        // Re-attach listeners for these newly cloned/copied buttons
                        attachListenersToSelectorNextExecuteOptions();
                    }
                    showPanel('panel-selector-activated');
                });
            });
             // Manual selector entry in panel-targets
            const manualSelEntryBtn = document.querySelector('#panel-targets .panel-button[data-action="manual-selector-entry"]');
            if(manualSelEntryBtn) {
                manualSelEntryBtn.addEventListener('click', () => {
                    addCommandSegment('', 'selector_name_manual_input', {
                        isEditableInput: true,
                        placeholder: 'selector/name',
                        sourcePanelId: 'panel-targets',
                        // nextPanelAfterInput logic would be complex here, maybe back to execute subcommands
                    });
                    showPanel('panel-execute-subcommands'); // Or stay and user clicks next
                });
            }


            // --- Panel Selector Activated ---
            // A. Clicking a selector argument KEY (e.g., type=)
            selectorArgsOptionsContainer.querySelectorAll('.panel-button[data-selector-arg-key]').forEach(button => {
                button.addEventListener('click', () => {
                    if (!pendingSelector) return; 

                    if (!selectorArgState.isActive) { // First argument for this selector
                        const baseSelPart = addCommandSegment(pendingSelector, 'selector_base', { sourcePanelId: 'panel-selector-activated' });
                        selectorArgState.baseSelectorPartId = baseSelPart.id;
                        addCommandSegment('[', 'bracket_open', { sourcePanelId: 'panel-selector-activated' });
                        selectorArgState.isActive = true;
                        selectorArgState.hasOpenBracket = true;
                    } else { // Subsequent argument
                        addCommandSegment(',', 'comma', { sourcePanelId: 'panel-selector-activated' });
                    }
                    
                    const argKeyText = button.dataset.selectorArgKey;
                    addCommandSegment(argKeyText, 'selector_arg_key', { sourcePanelId: 'panel-selector-activated' });

                    // Now add the editable input field for the argument's value
                    if (argKeyText === 'type=') {
                        activeInputTarget = { forArgKey: argKeyText }; // Context for entity list
                        showFullscreenList('fullscreen-entity-list');
                    } else if (argKeyText === 'limit=' || argKeyText === 'distance=') { // Example numeric
                        addCommandSegment('', 'selector_arg_value_input', {isEditableInput:true, placeholder:'number', requiresInput:'keypad', nextPanelAfterInput:'panel-selector-activated', sourcePanelId: 'panel-selector-activated'});
                    } else { // Default to text input (e.g. name=, tag=)
                        addCommandSegment('', 'selector_arg_value_input', {isEditableInput:true, placeholder:'value', nextPanelAfterInput:'panel-selector-activated', sourcePanelId: 'panel-selector-activated'});
                    }
                });
            });
            
            // B. Clicking "Next Execute Subcommand" from panel-selector-activated
            function attachListenersToSelectorNextExecuteOptions() { /* ... as before, calls handleExecuteSubcommandClick ... */ }
            // This function will be called by the event listeners attached in attachListenersToSelectorNextExecuteOptions
            function handleNextExecuteSubcommandFromSelectorPanel(subcommandName) {
                if (!pendingSelector) return;

                if (selectorArgState.isActive && selectorArgState.hasOpenBracket) { 
                    addCommandSegment(']', 'bracket_close', { sourcePanelId: 'panel-selector-activated' });
                } else if (!selectorArgState.isActive) { // No args were added, just add the plain selector
                    addCommandSegment(pendingSelector, 'selector_base', { sourcePanelId: 'panel-selector-activated' });
                }
                
                addCommandSegment(subcommandName, 'keyword', { sourcePanelId: 'panel-selector-activated' }); 
                
                pendingSelector = null; 
                selectorArgState = { isActive: false, baseSelectorPartId: null, hasOpenBracket: false };

                const nextPanel = getNextPanelForExecuteSubcommand(subcommandName);
                showPanel(nextPanel);
            }
            // Ensure listeners in selectorNextExecuteOptionsContainer call handleNextExecuteSubcommandFromSelectorPanel
             function attachListenersToSelectorNextExecuteOptions() {
                selectorNextExecuteOptionsContainer.querySelectorAll('.panel-button[data-subcommand]').forEach(button => {
                    const newButton = button.cloneNode(true); // Clone to remove old listeners
                    button.parentNode.replaceChild(newButton, button);
                    newButton.addEventListener('click', () => {
                        handleNextExecuteSubcommandFromSelectorPanel(newButton.dataset.subcommand);
                    });
                });
            }


            // --- Main Execute Subcommands Panel ---
            document.querySelectorAll('#panel-execute-subcommands .panel-button[data-subcommand]').forEach(button => {
                 button.addEventListener('click', () => {
                    const subcommand = button.dataset.subcommand;
                    // If a selector was active (e.g. from a previous step) and its args were being processed, close it.
                    if (selectorArgState.isActive && selectorArgState.hasOpenBracket) {
                        addCommandSegment(']', 'bracket_close', {sourcePanelId: 'panel-execute-subcommands'});
                    }
                    selectorArgState = { isActive: false, baseSelectorPartId: null, hasOpenBracket: false }; // Reset selector state
                    pendingSelector = null;

                    addCommandSegment(subcommand, 'keyword', {sourcePanelId: 'panel-execute-subcommands'});
                    const nextPanel = getNextPanelForExecuteSubcommand(subcommand);
                    if (nextPanel) showPanel(nextPanel);
                 });
            });
            
            // --- Fullscreen List Back Buttons ---
             document.querySelectorAll('.fullscreen-list-back-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Determine which panel to return to based on context
                    let targetPanel = 'panel-execute-subcommands'; // Default
                    if (selectorArgState.isActive && pendingSelector) {
                        targetPanel = 'panel-selector-activated'; // If we were adding args to a selector
                    } else if (pendingSelector) { // If a selector was pending but no args started
                         targetPanel = 'panel-selector-activated';
                    }
                    // If returning from entity list specifically for summon command, different logic might be needed.
                    // For now, this generic return should work for selector args.
                    hideCurrentFullscreenListAndShowPanel(targetPanel);
                    activeInputTarget = null; 
                });
            });
            
            // --- Dimensions Panel ---
            document.querySelectorAll('#panel-dimensions .panel-button[data-dimension]').forEach(button => {
                button.addEventListener('click', () => {
                    addCommandSegment(button.dataset.dimension, 'dimension_value', {sourcePanelId: 'panel-dimensions'});
                    showPanel('panel-execute-subcommands'); 
                });
            });
            
            // --- Copy Button ---
            if(copyButton) { /* ... same copy logic, but it will read from input.value for editable parts ... */ }

            setupKeypadListeners();

        } // End setupEventListeners
        
        // --- Helper: Get Next Panel for Execute Subcommands ---
        function getNextPanelForExecuteSubcommand(subcommand) { /* ... same ... */ }
        
        // --- Specific Command Handlers (called from lists or specific panels) ---
        function handleEntityTypeSelection(entityType) {
            // Context: filling value for 'type=' selector argument OR for 'summon' command.
            if (activeInputTarget && activeInputTarget.forArgKey === 'type=') {
                addCommandSegment(entityType, 'selector_arg_value_input', { isEditableInput: false, text: entityType, sourcePanelId: 'fullscreen-entity-list' }); // Not editable after selection from list
                activeInputTarget = null;
                hideCurrentFullscreenListAndShowPanel('panel-selector-activated');
            } else if (commandParts.length > 0 && commandParts[commandParts.length-1].type === 'keyword' && commandParts[commandParts.length-1].text === 'summon') {
                addCommandSegment(entityType, 'entity_type_for_summon', { sourcePanelId: 'fullscreen-entity-list' });
                // TODO: Next step for summon: get position
                addCommandSegment('', 'coordinates_input', { isEditableInput: true, placeholder:'x y z', requiresInput:'keypad', nextPanelAfterInput:'panel-execute-subcommands', sourcePanelId: 'fullscreen-entity-list' });
                hideCurrentFullscreenListAndShowPanel('panel-execute-subcommands'); // Or a summon-specific args panel
            } else {
                console.warn("Entity type selected out of context.");
                hideCurrentFullscreenListAndShowPanel('panel-execute-subcommands'); // Fallback
            }
        }

        function handleRunCommandSelection(commandInfo) { /* ... same general structure, ensure it calls specific handlers ... */ }
        // Example specific handlers (you'll need to implement the logic for each)
        function handleSayCommand() { /* add 'say', then add text input for message */ }
        function handleTpCommand() { /* add 'tp', then panel-targets for who, then options for where */ }
        function handleSummonCommand() { /* add 'summon', then show fullscreen-entity-list */ }
        // ... and so on for other run commands

        // --- START ---
        initialize();
    </script>
</body>
</html>

